<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - cube</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<!--<link type="text/css" rel="stylesheet" href="main.css">-->
	</head>
	<body>

		<script type="module">

			import * as THREE from '../three.js-master/build/three.module.js';
			import { OrbitControls } from '../three.js-master/examples/jsm/controls/OrbitControls.js';

			let camera, scene, controls, renderer;

			init();
			animate();

			function init() {

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x000000 );
				//---
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMapEnabled = true;
				document.body.appendChild( renderer.domElement );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 400, 200, 0 );

				//Ambient light
				const nightLight = new THREE.AmbientLight( 0xffffff, 0.3) ;
				scene.add(nightLight);

				// controls

				controls = new OrbitControls( camera, renderer.domElement );

				//controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

				controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
				controls.dampingFactor = 0.05;

				controls.screenSpacePanning = false;

				controls.minDistance = 100;
				controls.maxDistance = 500;

				controls.maxPolarAngle = Math.PI / 2;

				//La bougie
				function candle(posX,posY,posZ,renderer){
					var clock = new THREE.Clock();
			 		var time = 0;

					//// Candle
					var candleFoot = new THREE.CylinderGeometry(2, 2, 6, 10);
					var candleMaterial = new THREE.MeshPhongMaterial({
					 color: 0xECEAE8
					});
					var candle = new THREE.Mesh(candleFoot, candleMaterial);
					candle.castShadow = true;
					candle.receiveShadow = true;
					candle.position.set(posX,posY,posZ);
					scene.add(candle);

					//// Candlewick
					var candlewickProfile = new THREE.Shape();

					// On créer le plan de notre forme
					candlewickProfile.absarc(0, 0, 0.0625);

					// Notre mèche a trois points
					var candlewickCurve = new THREE.CatmullRomCurve3([
					  new THREE.Vector3(0, 0, 0),
					  new THREE.Vector3(0, 0.5, -0.0625),
					  new THREE.Vector3(0.25, 0.5, 0.125)
					]);

					// On utilise la forme qui va prendre la méthode buffer(pour alleger le processus des vecteurs pour le GPU), elle va se faire en 8 étapes et suivre les 3 points. Bevel signifie "biseauter" ou encore "chanfreiner". Très honnêtement ca ne semble rien changer mais je voulais voir ce que ca faisait.
					var candlewickGeo = new THREE.ExtrudeBufferGeometry(candlewickProfile, {
						steps: 8,
						bevelEnabled: false,
					  extrudePath: candlewickCurve
					});

					// Permet la translation, sans quoi ca ne marche pas. C'est la position à laquelle cela va être fait, on set plus tard la hauteur pour la changer dans le temple.
					candlewickGeo.translate(0, 0.95, 0);
					var candlewickMat = new THREE.MeshBasicMaterial({color:"black"});
					var candlewickMesh = new THREE.Mesh(candlewickGeo, candlewickMat);
					candlewickMesh.position.set(0,2,0)
					candle.add(candlewickMesh);

					//// Flame
				  	let flameGeo1 = new THREE.OctahedronGeometry(1,3);
				  	let flameMat1 = new THREE.MeshPhongMaterial({
				  		color : "#F09903"
				  	});
				  	let flame1 = new THREE.Mesh(flameGeo1, flameMat1);
				  	flame1.position.y = 2.5;
				  	candlewickMesh.add(flame1);

				  	let flameGeo2 = new THREE.OctahedronGeometry(1,3);
				  	let flameMat2 = new THREE.MeshPhongMaterial({
				  		color : "#E8B61D"
				  	});
				  	let flame2 = new THREE.Mesh(flameGeo2, flameMat2);
				  	flame2.position.y = 2.8;
				  	candlewickMesh.add(flame2);

					//// Candle two light
					var candleLight = new THREE.PointLight(0xffaa33, 1, 5, 2);
			      	candleLight.position.set(0, 3, 0);
			      	candleLight.castShadow = true; 
				  	candlewickMesh.add(candleLight);
			      	var candleLight2 = new THREE.PointLight(0xffaa33, 1, 100, 1);
			      	candleLight2.position.set(0, 4, 0);
			      	candleLight2.castShadow = true;
			      	candlewickMesh.add(candleLight2);

					render(renderer);

					function render(){
			 			requestAnimationFrame(render);
			 			time += clock.getDelta();
			        	//flameMaterials[0].uniforms.time.value = time;
			        	//flameMaterials[1].uniforms.time.value = time;
			        	candleLight2.position.x = Math.sin(time * Math.PI) * 0.25;
			        	candleLight2.position.z = Math.cos(time * Math.PI * 0.75) * 0.25;
			        	flame2.position.x = (Math.sin(time * Math.PI) * 0.25)/2;
			        	flame2.position.z = (Math.cos(time * Math.PI * 0.75) * 0.25)/2;
			        	candleLight2.intensity = 2 + Math.sin(time * Math.PI * 2) * Math.cos(time * Math.PI * 1.5) * 0.25;
			 			controls.update();
					}
				}
				// FUNCTION
				function ground(scene){
					let ground;
					const texture = new THREE.TextureLoader().load( 'Texture/marbredore.png' );
					const geometry = new THREE.BoxBufferGeometry( 200, 2, 300 );
					const material = new THREE.MeshPhongMaterial( {map: texture} );
					ground = new THREE.Mesh( geometry, material );
					ground.castShadow = true;
					ground.receiveShadow = true;
					scene.add(ground);
				}
				function symbol(posx,posy,posz,scene){
					let symbol;
					const texture = new THREE.TextureLoader().load( 'Texture/symbol.jpg' );
					const geometry = new THREE.SphereGeometry( 34, 50, 72 );
					const material = new THREE.MeshPhongMaterial( { map: texture} );
					symbol = new THREE.Mesh( geometry, material);
					symbol.position.set(posx,posy,posz);
					scene.add(symbol);
				}
				function poolWater(posy,scene){
					let pool;
					const texture = new THREE.TextureLoader().load( 'Texture/pool.jpg' );
					const geometry = new THREE.BoxBufferGeometry( 45, 4, 115 );
					const material = new THREE.MeshPhongMaterial( {map: texture} );
					pool = new THREE.Mesh( geometry, material);
					pool.position.y = posy;
					scene.add(pool);
				}
				function poolGround1(posy,scene){
					let poolGround;
					const texture = new THREE.TextureLoader().load( 'Texture/poolGround.jpg' );
					const geometry = new THREE.BoxBufferGeometry( 90, 4, 170 );
					const material = new THREE.MeshPhongMaterial( {map: texture} );
					poolGround = new THREE.Mesh( geometry, material);
					poolGround.position.y = posy;
					scene.add(poolGround);
				}
				function poolGround2(posy,scene){
					let poolGround;
					const texture = new THREE.TextureLoader().load( 'Texture/poolGround2.jpg' );
					const geometry = new THREE.BoxBufferGeometry( 80, 4, 150 );
					const material = new THREE.MeshPhongMaterial( {map: texture} );
					poolGround = new THREE.Mesh( geometry, material);
					poolGround.position.y = posy;
					scene.add(poolGround);
				}
				function poolGround3(posy,scene){
					let poolGround;
					const texture = new THREE.TextureLoader().load( 'Texture/poolGround3.jpg' );
					const geometry = new THREE.BoxBufferGeometry( 60, 4, 130 );
					const material = new THREE.MeshPhongMaterial( {map: texture} );
					poolGround = new THREE.Mesh( geometry, material);
					poolGround.position.y = posy;
					scene.add(poolGround);
				}
				function wall1(posx,posy,posz,scene){
					let wall;
					const texture = new THREE.TextureLoader().load( 'Texture/marbre.jpg' );
					const geometry = new THREE.BoxBufferGeometry( 126, 120, 2 );
					const material = new THREE.MeshPhongMaterial( {map: texture} );
					wall = new THREE.Mesh( geometry, material);
					wall.castShadow = true;
					wall.receiveShadow = true;
					wall.position.set(posx,posy,posz);
					scene.add(wall);
				}
				function wall2(posx,posy,posz,scene){
					let wall;
					const texture = new THREE.TextureLoader().load( 'Texture/marbre.jpg' );
					const geometry = new THREE.BoxBufferGeometry( 2, 120, 210 );
					const material = new THREE.MeshPhongMaterial( {map: texture} );
					wall = new THREE.Mesh( geometry, material);
					wall.castShadow = true;
					wall.receiveShadow = true;
					wall.position.set(posx,posy,posz);
					scene.add(wall);
				}
				function wall3(posx,posy,posz,scene){
					let wall;
					const texture = new THREE.TextureLoader().load( 'Texture/marbre.jpg' );
					const geometry = new THREE.BoxBufferGeometry( 50, 120, 2 );
					const material = new THREE.MeshPhongMaterial( {map: texture} );
					wall = new THREE.Mesh( geometry, material);
					wall.castShadow = true;
					wall.receiveShadow = true;
					wall.position.set(posx,posy,posz);
					scene.add(wall);
				}
				function pillar(posx,posy,posz,scene){
					let pilier;
					const texture = new THREE.TextureLoader().load( 'Texture/gold.jpg' );
					const geometry = new THREE.CylinderBufferGeometry( 5, 5, 120, 20 );
					const material = new THREE.MeshPhongMaterial( {map: texture} );
					pilier = new THREE.Mesh( geometry, material );
					pilier.castShadow = true;
					pilier.receiveShadow = true;
					pilier.position.set(posx,posy,posz);
					scene.add(pilier);
				}
				function triangleRoof(posy,posz,posrot,scene){
					let triangle;
					const texture = new THREE.TextureLoader().load( 'Texture/gold.jpg' );	
					const geometry = new THREE.ConeGeometry( 100, 50, 2 );
					const material = new THREE.MeshPhongMaterial( {map: texture} );
					triangle = new THREE.Mesh( geometry, material );
					triangle.position.set("",posy,posz);
					triangle.rotation.y = posrot;
					scene.add(triangle);
				}
				function roof1(posy,scene){
					let roof;
					const texture = new THREE.TextureLoader().load( 'Texture/poolGround2.jpg' );
					const geometry = new THREE.BoxBufferGeometry( 200, 5, 260 );
					const material = new THREE.MeshPhongMaterial( {map: texture} );
					roof = new THREE.Mesh(geometry, material);
					roof.position.y = posy;
					scene.add(roof);
				}
				function roof2(posy,scene){
					let roof;
					const texture = new THREE.TextureLoader().load( 'Texture/marbredore.png' );
					const geometry = new THREE.BoxBufferGeometry( 200, 2, 300 );
					const material = new THREE.MeshPhongMaterial( {map: texture} );
					roof = new THREE.Mesh(geometry, material);
					roof.position.y = posy;
					scene.add(roof);
				}

				//CALL OF FUNCTION

				//SOL
				ground(scene);

				//MURS
				//Mur Gauche
				wall2(65,60,"",scene);
				//Mur Droite
				wall2(-65,60,"",scene);
				//Mur Arrière
				wall1("",60,-105,scene);

				//Mur avant
				//Portes
				wall3(40,60,105,scene);
				wall3(-40,60,105,scene);

				//PISCINE
				poolWater(15,scene);
				poolGround1(5,scene);
				poolGround2(7,scene);
				poolGround3(10,scene);

				//SYMBOL
				symbol("",60,5,scene);

				//PILIER AVANT
				pillar(85,60,125,scene);
				pillar(65,60,125,scene);
				pillar(45,60,125,scene);
				pillar(25,60,125,scene);
				pillar(-25,60,125,scene);
				pillar(-45,60,125,scene);
				pillar(-65,60,125,scene);
				pillar(-85,60,125,scene);

				//PILIER ARRIÈRE
				pillar(85,60,-125,scene);
				pillar(65,60,-125,scene);
				pillar(45,60,-125,scene);
				pillar(25,60,-125,scene);
				pillar(-25,60,-125,scene);
				pillar(-45,60,-125,scene);
				pillar(-65,60,-125,scene);
				pillar(-85,60,-125,scene);

				//PILIER FLAN DROIT
				pillar(-85,60,105,scene);
				pillar(-85,60,85,scene);
				pillar(-85,60,65,scene);
				pillar(-85,60,45,scene);
				pillar(-85,60,25,scene);
				pillar(-85,60,5,scene);
				pillar(-85,60,-10,scene);
				pillar(-85,60,-25,scene);
				pillar(-85,60,-45,scene);
				pillar(-85,60,-65,scene);
				pillar(-85,60,-85,scene);
				pillar(-85,60,-105,scene);

				//PILIER FLAN GAUCHE
				pillar(85,60,105,scene);
				pillar(85,60,85,scene);
				pillar(85,60,65,scene);
				pillar(85,60,45,scene);
				pillar(85,60,25,scene);
				pillar(85,60,5,scene);
				pillar(85,60,-10,scene);
				pillar(85,60,-25,scene);
				pillar(85,60,-45,scene);
				pillar(85,60,-65,scene);
				pillar(85,60,-85,scene);
				pillar(85,60,-105,scene);

				//TOIT
				roof1(120,scene);
				roof2(125,scene);

				triangleRoof(150,120,Math.PI / 2,scene);
				triangleRoof(150,100,Math.PI / 2,scene);
				triangleRoof(150,80,Math.PI / 2,scene);
				triangleRoof(150,60,Math.PI / 2,scene);
				triangleRoof(150,40,Math.PI / 2,scene);
				triangleRoof(150,20,Math.PI / 2,scene);
				triangleRoof(150,0,Math.PI / 2,scene);
				triangleRoof(150,-20,Math.PI / 2,scene);
				triangleRoof(150,-40,Math.PI / 2,scene);
				triangleRoof(150,-60,Math.PI / 2,scene);
				triangleRoof(150,-80,Math.PI / 2,scene);
				triangleRoof(150,-100,Math.PI / 2,scene);
				triangleRoof(150,-120,Math.PI / 2,scene);

				//BOUGIES
				candle(95,4,145,renderer);
				candle(-95,4,145,renderer);
				candle(95,4,-145,renderer);
				candle(-95,4,-145,renderer);
				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}
			function animate() {

				requestAnimationFrame( animate );

				controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

				render();

			}

			function render() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>